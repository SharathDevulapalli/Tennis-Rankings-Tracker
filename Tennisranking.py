{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1bf27841-be97-4c82-8d1e-07db28c7f4f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "from selenium import webdriver\n",
    "from selenium.webdriver.chrome.service import Service\n",
    "from selenium.webdriver.chrome.options import Options\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "from bs4 import BeautifulSoup\n",
    "import pandas as pd\n",
    "import tkinter as tk\n",
    "from tkinter import ttk\n",
    "from datetime import datetime, timedelta\n",
    "from matplotlib.colors import LinearSegmentedColormap\n",
    "\n",
    "def scrape_rankings(url_base, start_date, end_date):\n",
    "    # Configure Chrome options for headless mode\n",
    "    chrome_options = Options()\n",
    "    chrome_options.add_argument(\"--headless\")\n",
    "    chrome_options.add_argument(\"--disable-gpu\")\n",
    "    chrome_options.add_argument(\"--window-size=1920x1080\")\n",
    "\n",
    "    # Initialize the Selenium WebDriver with headless option\n",
    "    service = Service('/path/to/ChromeDriver')  # Update the path to your ChromeDriver\n",
    "    driver = webdriver.Chrome(service=service, options=chrome_options)\n",
    "\n",
    "    # Generate a list of weekly dates in the correct format (YYYY-MM-DD)\n",
    "    dates = []\n",
    "    current_date = start_date\n",
    "    while current_date <= end_date:\n",
    "        dates.append(current_date.strftime(\"%Y-%m-%d\"))\n",
    "        current_date += timedelta(days=7)\n",
    "\n",
    "    # Initialize an empty DataFrame to store the data\n",
    "    df = pd.DataFrame()\n",
    "\n",
    "    # Iterate through each date and scrape the data\n",
    "    for date in dates:\n",
    "        url = f\"{url_base}?date={date}\"\n",
    "        \n",
    "        # Open the page with Selenium\n",
    "        driver.get(url)\n",
    "        \n",
    "        # Wait for the correct table to load\n",
    "        WebDriverWait(driver, 10).until(\n",
    "            EC.presence_of_element_located((By.CLASS_NAME, \"result\"))\n",
    "        )\n",
    "        \n",
    "        # Get the page source after JavaScript has loaded content\n",
    "        html = driver.page_source\n",
    "        \n",
    "        # Pass it to BeautifulSoup\n",
    "        soup = BeautifulSoup(html, \"html.parser\")\n",
    "        \n",
    "        # Find the second table (which we identified as containing the rankings)\n",
    "        tables = soup.find_all(\"table\", {\"class\": \"result\"})\n",
    "        if len(tables) < 2:\n",
    "            continue  # Skip if the table is not found\n",
    "\n",
    "        ranking_table = tables[1]  # Index 1 corresponds to the second table\n",
    "        \n",
    "        # Extract rows from the ranking table\n",
    "        rows = ranking_table.find_all(\"tr\")[1:]  # Skip the header row\n",
    "        \n",
    "        # Extract data from each row and update the DataFrame\n",
    "        for row in rows:\n",
    "            cells = row.find_all(\"td\")\n",
    "            if len(cells) >= 4:\n",
    "                rank = cells[0].text.strip().replace('.', '')\n",
    "                name = cells[2].text.strip()\n",
    "                country = cells[3].text.strip()\n",
    "                point = cells[4].text.strip().replace(',', '')  # Remove commas for numeric conversion\n",
    "                \n",
    "                # Create a unique identifier for each player-country combination\n",
    "                player_id = f\"{name}-{country}\"\n",
    "                \n",
    "                # Update the DataFrame with the points for this date, using player-country as index\n",
    "                df.loc[player_id, 'Player Name'] = name\n",
    "                df.loc[player_id, 'Country'] = country\n",
    "                df.loc[player_id, date] = int(float(point)) if point.isdigit() else None\n",
    "\n",
    "    # Close the Selenium browser\n",
    "    driver.quit()\n",
    "    \n",
    "    # Extract only the date columns (dynamically identified)\n",
    "    date_columns = df.columns.difference(['Player Name', 'Country'])\n",
    "    \n",
    "    if not df.empty and len(date_columns) > 0:\n",
    "        # Calculate YTD Change for each player using their first and last available dates\n",
    "        def calculate_ytd_change(row):\n",
    "            first_valid_date = row[date_columns].first_valid_index()\n",
    "            last_valid_date = row[date_columns].last_valid_index()\n",
    "            if pd.notna(first_valid_date) and pd.notna(last_valid_date):\n",
    "                return int(row[last_valid_date] - row[first_valid_date])\n",
    "            else:\n",
    "                return None\n",
    "\n",
    "        # Apply the function to calculate YTD Change\n",
    "        df['YTD Change'] = df.apply(calculate_ytd_change, axis=1)\n",
    "        \n",
    "        # Sort by the YTD Change in descending order\n",
    "        df = df.sort_values(by='YTD Change', ascending=False)\n",
    "    \n",
    "    print(\"All data extracted successfully.\")\n",
    "    return df, date_columns\n",
    "\n",
    "# Set the start and end dates\n",
    "start_date = datetime.strptime(\"01.01.2024\", \"%d.%m.%Y\")\n",
    "end_date = datetime.today()\n",
    "\n",
    "# Scrape WTA Rankings\n",
    "wta_df, wta_date_columns = scrape_rankings(\"https://www.tennisexplorer.com/ranking/wta-women/\", start_date, end_date)\n",
    "\n",
    "# Scrape ATP Rankings\n",
    "atp_df, atp_date_columns = scrape_rankings(\"https://www.tennisexplorer.com/ranking/atp-men/\", start_date, end_date)\n",
    "\n",
    "# Function to create a dynamic color gradient\n",
    "def get_gradient_color(value, min_value, max_value):\n",
    "    norm_value = (value - min_value) / (max_value - min_value)\n",
    "    cmap = LinearSegmentedColormap.from_list('my_cmap', ['#ffcccc', 'white', '#ccffcc'])\n",
    "    return cmap(norm_value)\n",
    "\n",
    "# Create the main application window\n",
    "class TennisRankingsApp(tk.Tk):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "\n",
    "        self.title(\"Tennis Player Performance\")\n",
    "        self.geometry(\"1200x700\")\n",
    "\n",
    "        # Corrected to calculate max date properly\n",
    "        max_wta_date = max(wta_date_columns)\n",
    "        max_atp_date = max(atp_date_columns)\n",
    "        last_update = max(max_wta_date, max_atp_date)\n",
    "\n",
    "        title_label = tk.Label(self, text=\"Tennis Player Performance\", font=(\"Arial\", 16, \"bold\"))\n",
    "        title_label.pack(pady=10)\n",
    "        last_update_label = tk.Label(self, text=f\"Last Updated: {last_update}\", font=(\"Arial\", 12))\n",
    "        last_update_label.pack(pady=5)\n",
    "\n",
    "        # Create the notebook for WTA and ATP tabs\n",
    "        notebook = ttk.Notebook(self)\n",
    "        notebook.pack(expand=True, fill='both')\n",
    "\n",
    "        # Create tabs\n",
    "        self.create_tab(notebook, \"WTA Rankings\", wta_df, wta_date_columns)\n",
    "        self.create_tab(notebook, \"ATP Rankings\", atp_df, atp_date_columns)\n",
    "\n",
    "        # Add a small note in the bottom right corner\n",
    "        note_label = tk.Label(self, text=\"All data taken from tennisexplorer.com\", font=(\"Arial\", 8), anchor='e')\n",
    "        note_label.pack(side=\"bottom\", anchor=\"se\", padx=10, pady=5)\n",
    "\n",
    "    def create_tab(self, notebook, title, data, date_columns):\n",
    "        frame = ttk.Frame(notebook)\n",
    "        frame.pack(fill=\"both\", expand=True)\n",
    "        notebook.add(frame, text=title)\n",
    "\n",
    "        # Create a Treeview widget for showing rankings\n",
    "        columns = ['Player Name', 'Country', 'YTD Change']\n",
    "        tree = ttk.Treeview(frame, columns=columns, show='headings')\n",
    "        tree.heading('Player Name', text='Player Name')\n",
    "        tree.heading('Country', text='Country')\n",
    "        tree.heading('YTD Change', text='YTD Change')\n",
    "\n",
    "        # Adding the horizontal scrollbar\n",
    "        h_scrollbar = ttk.Scrollbar(frame, orient=\"horizontal\", command=tree.xview)\n",
    "        h_scrollbar.pack(side=\"bottom\", fill=\"x\")\n",
    "        tree.configure(xscrollcommand=h_scrollbar.set)\n",
    "\n",
    "        # Apply style for center alignment of numbers\n",
    "        style = ttk.Style()\n",
    "        style.configure(\"Treeview.Heading\", anchor=\"center\")\n",
    "        style.configure(\"Treeview\", rowheight=25)\n",
    "\n",
    "        # Center align the numeric columns\n",
    "        for col in columns[2:]:\n",
    "            tree.column(col, anchor=\"center\")\n",
    "\n",
    "        # Conditional formatting and inserting rows\n",
    "        ytd_min = data['YTD Change'].min()\n",
    "        ytd_max = data['YTD Change'].max()\n",
    "\n",
    "        for i, row in data.iterrows():\n",
    "            ytd_change = row['YTD Change']\n",
    "            color = get_gradient_color(ytd_change, ytd_min, ytd_max)\n",
    "            rgb = tuple(int(255 * x) for x in color[:3])\n",
    "            hex_color = f'#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}'\n",
    "            player_id = tree.insert('', 'end', values=(row['Player Name'], row['Country'], '' if pd.isna(ytd_change) else int(ytd_change)))\n",
    "            tree.tag_configure(f'tag_{i}', background=hex_color)\n",
    "            tree.item(player_id, tags=(f'tag_{i}',))\n",
    "            # Store all data initially to populate when expanding\n",
    "            self.store_expansion_data(tree, player_id, row, date_columns)\n",
    "\n",
    "        tree.pack(expand=True, fill='both')\n",
    "\n",
    "        # Add a button to expand/collapse the table by columns\n",
    "        expand_button = tk.Button(frame, text=\"Expand/Collapse Weekly Points\", command=lambda: self.toggle_columns(tree, date_columns))\n",
    "        expand_button.pack(pady=10)\n",
    "\n",
    "    def store_expansion_data(self, tree, player_id, row, date_columns):\n",
    "        try:\n",
    "            expanded_values = [int(float(value)) if isinstance(value, (int, float)) and not pd.isna(value) else '' for value in [row.get(col, None) for col in date_columns]]\n",
    "            current_values = list(tree.item(player_id)['values'])  # Convert current tuple to list\n",
    "            tree.item(player_id, values=tuple(current_values + expanded_values))  # Convert back to tuple after concatenation\n",
    "        except Exception as e:\n",
    "            print(f\"Error encountered: {e}\")\n",
    "\n",
    "\n",
    "    def toggle_columns(self, tree, date_columns):\n",
    "        current_columns = tree[\"columns\"]\n",
    "\n",
    "        # Check if the table is currently expanded (i.e., includes date columns)\n",
    "        if len(current_columns) > 3:  # More than 'Player Name', 'Country', 'YTD Change'\n",
    "            # Collapse - Only show the base columns\n",
    "            tree[\"columns\"] = ['Player Name', 'Country', 'YTD Change']\n",
    "        else:\n",
    "            # Expand - Show all columns including the weekly points\n",
    "            tree[\"columns\"] = ['Player Name', 'Country', 'YTD Change'] + list(date_columns)\n",
    "    \n",
    "        # Always reset the headings regardless of the state\n",
    "        tree.heading('Player Name', text='Player Name')\n",
    "        tree.heading('Country', text='Country')\n",
    "        tree.heading('YTD Change', text='YTD Change')\n",
    "    \n",
    "        if len(current_columns) > 3:\n",
    "            # If collapsing, we don't need to reset all date column headings\n",
    "            for col in date_columns:\n",
    "                if tree.exists(col):\n",
    "                    tree.heading(col, text=\"\")\n",
    "                    tree.column(col, width=0)\n",
    "        else:\n",
    "            # If expanding, reset all date column headings\n",
    "            for col in date_columns:\n",
    "                tree.heading(col, text=col)\n",
    "                tree.column(col, anchor=\"center\", width=100)  # Set a default width for date columns\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    app = TennisRankingsApp()\n",
    "    app.mainloop()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
